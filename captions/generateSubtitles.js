const Creatomate = require('creatomate');
const srtparsejs = require('srtparsejs');
const downloadS3File = require('./downloadS3File');
const fetchTranscript = require('./fetchTranscript');
const timestampToSeconds = require('./timestampToSeconds');

async function generateSubtitles(awsRegion, bucketName, bucketKey) {

  const keyframes = [];

  // Fetch the SRT file generated by AWS Transcribe
  const subtitles = await downloadS3File(awsRegion, bucketName, bucketKey + '.srt');

  // Fetch the transcript result
  const transcript = await fetchTranscript(awsRegion, bucketName, bucketKey);

  // Iterate through each sentence in the SRT file
  for (const sentence of srtparsejs.parse(subtitles)) {

    // Convert each timestamp in the SRT to seconds
    const startTime = timestampToSeconds(sentence.startTime);
    const endTime = timestampToSeconds(sentence.endTime);

    // Get the words that correspond to this sentence
    const words = transcript.filter((word) => (
      word.startTime >= startTime && word.startTime < endTime
    ));

    // Iterate through each word
    for (let i = 0; i < words.length; i++) {
      const word = words[i];

      let text = '';

      // Encapsulate each spoken word with an RGBA color tag, to make it slightly transparent
      const spokenWords = words.slice(0, i);
      if (spokenWords.length > 0) {
        text += `[color rgba(255,255,255,0.4)]${
          spokenWords.map((word) => word.content).join(' ')}[/color] `;
      }

      // Encapsulate the current spoken word with a color tag to make it fully white
      text += `[color #fff]${word.content}[/color]`;

      // Add the words that have not yet been spoken. As the default 'fillColor' is null,
      // the text will be invisible, but reserve its space in the text element
      const unspokenWords = words.slice(i + 1);
      if (unspokenWords.length) {
        text += ` ${unspokenWords.map((word) => word.content).join(' ')}`;
      }

      // Create a keyframe for each spoken word
      keyframes.push(new Creatomate.Keyframe(text, word.startTime));
    }
  }

  return keyframes;
}

module.exports = generateSubtitles;
